#######################################################
# pybird: python for biased tracers in redshift space
# - Pierre Zhang -
# 15/01/2020
#######################################################


import os
#from time import time
#from timeit import timeit, Timer
import numpy as np
from numpy import pi, sin, log, exp
#from numpy.fft import rfft
from pyfftw.builders import rfft
from scipy.interpolate import interp1d
from scipy.special import gamma
from scipy.integrate import quad
#import matplotlib.pyplot as plt

mu = {
    0: { 0: 1., 2: 0., 4: 0. },
    2: { 0: 1./3., 2: 2./3., 4: 0. },
    4: { 0: 1./5., 2: 4./7., 4: 8./35. },
    6: { 0: 1./7., 2: 10./21., 4: 24./77. },
    8: { 0: 1./9., 2: 40./99., 4: 48./148. }
}

M13b = {
    0: lambda n1: 1.125,
    1: lambda n1: -(1/(1 + n1)),
    2: lambda n1: 2.25,
    3: lambda n1: (3*(-1 + 3*n1))/(4.*(1 + n1)),
    4: lambda n1: -(1/(1 + n1)),
    5: lambda n1: -9/(4 + 4*n1),
    6: lambda n1: (9 + 18*n1)/(4 + 4*n1),
    7: lambda n1: (3*(-5 + 3*n1))/(8.*(1 + n1)),
    8: lambda n1: -9/(4 + 4*n1),
    9: lambda n1: (9*n1)/(4 + 4*n1),
}

def M13a(n1):
    return np.tan(n1*np.pi)/(14.*(-3 + n1)*(-2 + n1)*(-1 + n1)*n1*np.pi)

M22b = {
    0: lambda n1, n2: (6 + n1**4*(4 - 24*n2) - 7*n2 + 8*n1**5*n2 - 13*n2**2 + 4*n2**3 + 4*n2**4 + n1**2*(-13 + 38*n2 + 12*n2**2 - 8*n2**3) + 2*n1**3*(2 - 5*n2 - 4*n2**2 + 8*n2**3) + n1*(-7 - 6*n2 + 38*n2**2 - 10*n2**3 - 24*n2**4 + 8*n2**5))/(4.*n1*(1 + n1)*(-1 + 2*n1)*n2*(1 + n2)*(-1 + 2*n2)),
    1: lambda n1, n2: (-18 + n1**2*(1 - 11*n2) - 12*n2 + n2**2 + 10*n2**3 + 2*n1**3*(5 + 7*n2) + n1*(-12 - 38*n2 - 11*n2**2 + 14*n2**3))/(7.*n1*(1 + n1)*n2*(1 + n2)),
    2: lambda n1, n2: (-3*n1 + 2*n1**2 + n2*(-3 + 2*n2))/(n1*n2),
    3: lambda n1, n2: (-4*(-24 + n2 + 10*n2**2) + 2*n1*(-2 + 51*n2 + 21*n2**2) + n1**2*(-40 + 42*n2 + 98*n2**2))/(49.*n1*(1 + n1)*n2*(1 + n2)),
    4: lambda n1, n2: (4*(3 - 2*n2 + n1*(-2 + 7*n2)))/(7.*n1*n2),
    5: lambda n1, n2: 2,
    6: lambda n1, n2: ((-3 + 2*n1 + 2*n2)*(-2 + 3*n2 + 4*n1**4*n2 + 3*n2**2 - 2*n2**3 + n1**3*(-2 - 2*n2 + 4*n2**2) + n1**2*(3 - 10*n2 - 4*n2**2 + 4*n2**3) + n1*(3 + 2*n2 - 10*n2**2 - 2*n2**3 + 4*n2**4)))/(2.*n1*(1 + n1)*(-1 + 2*n1)*n2*(1 + n2)*(-1 + 2*n2)),
    7: lambda n1, n2: ((-3 + 2*n1 + 2*n2)*(2 + 4*n2 + 5*n2**2 + n1**2*(5 + 7*n2) + n1*(4 + 10*n2 + 7*n2**2)))/(7.*n1*(1 + n1)*n2*(1 + n2)),
    8: lambda n1, n2: ((n1 + n2)*(-3 + 2*n1 + 2*n2))/(n1*n2),
    9: lambda n1, n2: ((-3 + 2*n1 + 2*n2)*(10 - 23*n2 + 28*n1**4*n2 + 5*n2**2 + 2*n2**3 + n1**3*(2 - 46*n2 + 28*n2**2) + n1**2*(5 - 38*n2 - 28*n2**2 + 28*n2**3) + n1*(-23 + 94*n2 - 38*n2**2 - 46*n2**3 + 28*n2**4)))/(14.*n1*(1 + n1)*(-1 + 2*n1)*n2*(1 + n2)*(-1 + 2*n2)),
    10: lambda n1, n2: ((-3 + 2*n1 + 2*n2)*(-58 + 4*n2 + 35*n2**2 + 7*n1**2*(5 + 7*n2) + n1*(4 + 14*n2 + 49*n2**2)))/(49.*n1*(1 + n1)*n2*(1 + n2)),
    11: lambda n1, n2: ((-3 + 2*n1 + 2*n2)*(-8 + 7*n1 + 7*n2))/(7.*n1*n2),
    12: lambda n1, n2: ((-3 + 2*n1 + 2*n2)*(-1 + 2*n1 + 2*n2)*(2 + 2*n1**3 - n2 - n2**2 + 2*n2**3 - n1**2*(1 + 2*n2) - n1*(1 + 2*n2 + 2*n2**2)))/(8.*n1*(1 + n1)*(-1 + 2*n1)*n2*(1 + n2)*(-1 + 2*n2)),
    13: lambda n1, n2: ((1 + n1 + n2)*(2 + n1 + n2)*(-3 + 2*n1 + 2*n2)*(-1 + 2*n1 + 2*n2))/(8.*n1*(1 + n1)*n2*(1 + n2)),
    14: lambda n1, n2: -((-3 + 2*n1 + 2*n2)*(-6 - n1 + 2*n1**2 - n2 + 2*n2**2))/(8.*n1*(1 + n1)*n2*(1 + n2)),
    15: lambda n1, n2: ((-3 + 2*n1 + 2*n2)*(-1 + 2*n1 + 2*n2)*(38 + 41*n2 + 112*n1**3*n2 - 66*n2**2 + 2*n1**2*(-33 - 18*n2 + 56*n2**2) + n1*(41 - 232*n2 - 36*n2**2 + 112*n2**3)))/(56.*n1*(1 + n1)*(-1 + 2*n1)*n2*(1 + n2)*(-1 + 2*n2)),
    16: lambda n1, n2: -((-3 + 2*n1 + 2*n2)*(9 + 3*n1 + 3*n2 + 7*n1*n2))/(14.*n1*(1 + n1)*n2*(1 + n2)),
    17: lambda n1, n2: ((-3 + 2*n1 + 2*n2)*(-1 + 2*n1 + 2*n2)*(5 + 5*n1 + 5*n2 + 7*n1*n2))/(14.*n1*(1 + n1)*n2*(1 + n2)),
    18: lambda n1, n2: (3 - 2*n1 - 2*n2)/(2.*n1*n2),
    19: lambda n1, n2: ((-3 + 2*n1 + 2*n2)*(-1 + 2*n1 + 2*n2))/(2.*n1*n2),
    20: lambda n1, n2: ((-3 + 2*n1 + 2*n2)*(-1 + 2*n1 + 2*n2)*(50 - 9*n2 + 98*n1**3*n2 - 35*n2**2 + 7*n1**2*(-5 - 18*n2 + 28*n2**2) + n1*(-9 - 66*n2 - 126*n2**2 + 98*n2**3)))/(196.*n1*(1 + n1)*(-1 + 2*n1)*n2*(1 + n2)*(-1 + 2*n2)),
    21: lambda n1, n2: ((-3 + 2*n1 + 2*n2)*(-1 + 2*n1 + 2*n2)*(2 + n1 + 4*n1**3 + n2 - 8*n1*n2 - 8*n1**2*n2 - 8*n1*n2**2 + 4*n2**3))/(8.*n1*(1 + n1)*(-1 + 2*n1)*n2*(1 + n2)*(-1 + 2*n2)),
    22: lambda n1, n2: ((2 + n1 + n2)*(-3 + 2*n1 + 2*n2)*(-1 + 2*n1 + 2*n2)*(1 + 2*n1 + 2*n2))/(8.*n1*(1 + n1)*n2*(1 + n2)),
    23: lambda n1, n2: -((-3 + 2*n1 + 2*n2)*(-1 + 2*n1 + 2*n2)*(-2 + 7*n1 + 7*n2))/(56.*n1*(1 + n1)*n2*(1 + n2)),
    24: lambda n1, n2: ((-3 + 2*n1 + 2*n2)*(-1 + 2*n1 + 2*n2)*(26 + 9*n2 + 56*n1**3*n2 - 38*n2**2 + 2*n1**2*(-19 - 18*n2 + 56*n2**2) + n1*(9 - 84*n2 - 36*n2**2 + 56*n2**3)))/(56.*n1*(1 + n1)*(-1 + 2*n1)*n2*(1 + n2)*(-1 + 2*n2)),
    25: lambda n1, n2: (3*(-3 + 2*n1 + 2*n2)*(-1 + 2*n1 + 2*n2))/(32.*n1*(1 + n1)*n2*(1 + n2)),
    26: lambda n1, n2: ((-3 + 2*n1 + 2*n2)*(-1 + 2*n1 + 2*n2)*(1 + 2*n1 + 2*n2)*(1 + 2*n1**2 - 8*n1*n2 + 2*n2**2))/(16.*n1*(1 + n1)*(-1 + 2*n1)*n2*(1 + n2)*(-1 + 2*n2)),
    27: lambda n1, n2: ((-3 + 2*n1 + 2*n2)*(-1 + 2*n1 + 2*n2)*(1 + 2*n1 + 2*n2)*(3 + 2*n1 + 2*n2))/(32.*n1*(1 + n1)*n2*(1 + n2)),
}

def M22a(n1, n2):
    return (gamma(1.5 - n1)*gamma(1.5 - n2)*gamma(-1.5 + n1 + n2))/(8.*np.pi**1.5*gamma(n1)*gamma(3 - n1 - n2)*gamma(n2))

### matrix for spherical bessel transform from Power spectrum to Correlation function
def MPC(l, pn):
    return np.pi**-1.5 * 2.**(-2.*pn) * gamma(1.5+l/2.-pn) / gamma(l/2.+pn)

def cH(Om,a):
    return np.sqrt(Om/a+a**2*(1-Om))
def DgN(Om,a):
    return 5./2*Om*cH(Om,a)/a*quad(lambda x:cH(Om,x)**-3,0,a)[0]
def fN(Om,z):
    a = 1./(1.+z)
    return (Om*(5*a - 3*DgN(Om,a)))/(2.*(a**3*(1 - Om) + Om)*DgN(Om,a))

Q100 = {
    0: lambda f: 0,
    1: lambda f: 0,
    2: lambda f: (-15 - 20*f - 22*f**2 - 12*f**3 - 3*f**4)/120.,
    3: lambda f: 0,
    4: lambda f: (35 + 70*f + 119*f**2 + 124*f**3 + 81*f**4 + 30*f**5 + 5*f**6)/840.,
    5: lambda f: 0,
    6: lambda f: (-315 - 840*f - 1932*f**2 - 2952*f**3 - 3098*f**4 - 2200*f**5 - 1020*f**6 - 280*f**7 - 35*f**8)/40320.,
    7: lambda f: 0,
    8: lambda f: (693 + 2310*f + 6699*f**2 + 13464*f**3 + 19426*f**4 + 20276*f**5 + 15270*f**6 + 8120*f**7 + 2905*f**8 + 630*f**9 + 63*f**10)/665280.,
    9: lambda f: 0,
    10: lambda f: (-15015 - 60060*f - 210210*f**2 - 523380*f**3 - 960245*f**4 - 1320280*f**5 - 1387404*f**6 - 1121512*f**7 - 685265*f**8 - 303660*f**9 - 91350*f**10 - 16632*f**11 - 1386*f**12)/1.3837824e8,
    11: lambda f: 0,
    12: lambda f: (6435 + 30030*f + 123123*f**2 + 365508*f**3 + 813527*f**4 + 1386970*f**5 + 1837335*f**6 + 1848280*f**7 + 1348025*f**8 + 677250*f**9 + 220185*f**10 + 41580*f**11 + 3465*f**12)/6.918912e8,
    13: lambda f: 0,
    14: lambda f: (-6435 - 34320*f - 161304*f**2 - 555984*f**3 - 1454596*f**4 - 2958800*f**5 - 4633800*f**6 - 5302160*f**7 - 4211650*f**8 - 2228400*f**9 - 745560*f**10 - 142560*f**11 - 11880*f**12)/9.4887936e9,
    15: lambda f: 0,
    16: lambda f: 0,
    17: lambda f: 0,
    18: lambda f: (-15 + 2*f**2 - 3*f**4)/180.,
    19: lambda f: (105 - 35*f**2 - 18*f**3 + 12*f**4)/630.,
    20: lambda f: (105 + 70*f + 21*f**2 - 36*f**3 + 3*f**4 + 30*f**5 + 15*f**6)/2520.,
    21: lambda f: (-105 - 70*f + 72*f**3 + 35*f**4 - 10*f**5 - 10*f**6)/1260.,
    22: lambda f: (-315 - 420*f - 420*f**2 - 36*f**3 + 182*f**4 + 20*f**5 - 180*f**6 - 140*f**7 - 35*f**8)/30240.,
    23: lambda f: (3465 + 4620*f + 3927*f**2 - 1386*f**3 - 4873*f**4 - 3040*f**5 + 225*f**6 + 910*f**7 + 280*f**8)/166320.,
    24: lambda f: (3465 + 6930*f + 11319*f**2 + 8712*f**3 + 330*f**4 - 4580*f**5 - 930*f**6 + 4200*f**7 + 4445*f**8 + 1890*f**9 + 315*f**10)/1.99584e6,
    25: lambda f: (-45045 - 90090*f - 138138*f**2 - 82368*f**3 + 62634*f**4 + 154700*f**5 + 105600*f**6 + 8400*f**7 - 29645*f**8 - 17010*f**9 - 3150*f**10)/1.297296e7,
    26: lambda f: (-9009 - 24024*f - 54054*f**2 - 72072*f**3 - 49907*f**4 + 1872*f**5 + 29532*f**6 + 8624*f**7 - 25095*f**8 - 32760*f**9 - 18774*f**10 - 5544*f**11 - 693*f**12)/4.1513472e7,
    27: lambda f: (45045 + 120120*f + 261261*f**2 + 321750*f**3 + 144430*f**4 - 204360*f**5 - 408510*f**6 - 298396*f**7 - 57015*f**8 + 70560*f**9 + 61425*f**10 + 20790*f**11 + 2772*f**12)/1.0378368e8,
    28: lambda f: (45045 + 150150*f + 429429*f**2 + 797940*f**3 + 947089*f**4 + 586690*f**5 - 64575*f**6 - 396424*f**7 - 143185*f**8 + 303786*f**9 + 469455*f**10 + 328020*f**11 + 132363*f**12 + 30030*f**13 + 3003*f**14)/2.0756736e9,
    29: lambda f: (-765765 - 2552550*f - 7147140*f**2 - 12777336*f**3 - 13518791*f**4 - 4073030*f**5 + 11069550*f**6 + 19496960*f**7 + 14913101*f**8 + 4148046*f**9 - 2750160*f**10 - 3428040*f**11 - 1638945*f**12 - 402402*f**13 - 42042*f**14)/1.76432256e10,
    30: lambda f: (-6435 - 25740*f - 89232*f**2 - 211068*f**3 - 344916*f**4 - 369980*f**5 - 176880*f**6 + 134292*f**7 + 237230*f**8 + 20412*f**9 - 212940*f**10 - 221760*f**11 - 106029*f**12 - 25740*f**13 - 2574*f**14)/3.5582976e9,
    31: lambda f: (109395 + 437580*f + 1495065*f**2 + 3456882*f**3 + 5360355*f**4 + 4923880*f**5 + 220065*f**6 - 6680490*f**7 - 9398383*f**8 - 5299668*f**9 + 272655*f**10 + 2180970*f**11 + 1303830*f**12 + 344916*f**13 + 36036*f**14)/3.02455296e10,
}

Q102 = {
    0: lambda f: 0,
    1: lambda f: 0,
    2: lambda f: 0,
    3: lambda f: -(f*(14 + 19*f + 12*f**2 + 3*f**3))/210.,
    4: lambda f: 0,
    5: lambda f: (f*(42 + 93*f + 112*f**2 + 78*f**3 + 30*f**4 + 5*f**5))/1260.,
    6: lambda f: 0,
    7: lambda f: -(f*(462 + 1419*f + 2508*f**2 + 2837*f**3 + 2110*f**4 + 1005*f**5 + 280*f**6 + 35*f**7))/55440.,
    8: lambda f: 0,
    9: lambda f: (f*(6006 + 23595*f + 54912*f**2 + 85748*f**3 + 94060*f**4 + 73170*f**5 + 39760*f**6 + 14420*f**7 + 3150*f**8 + 315*f**9))/4.32432e6,
    10: lambda f: 0,
    11: lambda f: -(f*(30030 + 143715*f + 414700*f**2 + 825175*f**3 + 1194500*f**4 + 1300454*f**5 + 1078112*f**6 + 670390*f**7 + 300510*f**8 + 91035*f**9 + 16632*f**10 + 1386*f**11))/1.729728e8,
    12: lambda f: 0,
    13: lambda f: (f*(6006 + 33891*f + 116688*f**2 + 282022*f**3 + 506750*f**4 + 695829*f**5 + 716912*f**6 + 530740*f**7 + 269010*f**8 + 87885*f**9 + 16632*f**10 + 1386*f**11))/3.459456e8,
    14: lambda f: 0,
    15: lambda f: -(f*(858 + 5577*f + 22308*f**2 + 63427*f**3 + 136070*f**4 + 220761*f**5 + 258248*f**6 + 207835*f**7 + 110790*f**8 + 37215*f**9 + 7128*f**10 + 594*f**11))/5.930496e8,
    16: lambda f: 0,
    17: lambda f: 0,
    18: lambda f: (f*(-350 - 159*f + 36*f**2 + 84*f**3))/12600.,
    19: lambda f: (f*(-98 + 273*f + 72*f**2 - 132*f**3))/8820.,
    20: lambda f: (f*(210 + 289*f + 184*f**2 - 29*f**3 - 80*f**4 - 30*f**5))/12600.,
    21: lambda f: (f*(294 + 70*f - 212*f**2 - 103*f**3 + 80*f**4 + 55*f**5))/8820.,
    22: lambda f: (f*(-16170 - 36861*f - 46596*f**2 - 27034*f**3 + 1370*f**4 + 12675*f**5 + 7420*f**6 + 1540*f**7))/3.3264e6,
    23: lambda f: -(f*(35574 + 45969*f + 11352*f**2 - 26882*f**3 - 18950*f**4 + 6585*f**5 + 10640*f**6 + 3080*f**7))/2.32848e6,
    24: lambda f: (f*(60060 + 190476*f + 353496*f**2 + 389129*f**3 + 228510*f**4 + 4035*f**5 - 103460*f**6 - 80745*f**7 - 28350*f**8 - 4095*f**9))/6.48648e7,
    25: lambda f: (f*(336336 + 747747*f + 779064*f**2 + 189046*f**3 - 385020*f**4 - 339960*f**5 + 27440*f**6 + 174930*f**7 + 94500*f**8 + 17325*f**9))/9.081072e7,
    26: lambda f: (f*(-54054 - 219219*f - 533676*f**2 - 839904*f**3 - 862780*f**4 - 508914*f**5 - 38136*f**6 + 219940*f**7 + 208530*f**8 + 97965*f**9 + 24948*f**10 + 2772*f**11))/4.1513472e8,
    27: lambda f: -(f*(882882 + 2753751*f + 4650360*f**2 + 4218240*f**3 + 1063700*f**4 - 1857462*f**5 - 1932336*f**6 - 216020*f**7 + 830970*f**8 + 671895*f**9 + 227304*f**10 + 30492*f**11))/1.45297152e9,
    28: lambda f: (f*(2552550 + 12595011*f + 37865256*f**2 + 76799489*f**3 + 109192700*f**4 + 106755240*f**5 + 63550984*f**6 + 7744954*f**7 - 25832394*f**8 - 28487445*f**9 - 16225440*f**10 - 5620923*f**11 - 1129128*f**12 - 102102*f**13))/1.76432256e11,
    29: lambda f: (f*(9291282 + 37165128*f + 85211412*f**2 + 121670003*f**3 + 101797700*f**4 + 26884803*f**5 - 40533248*f**6 - 48067082*f**7 - 12609198*f**8 + 15910230*f**9 + 18222204*f**10 + 8778231*f**11 + 2186184*f**12 + 231231*f**13))/1.235025792e11,
    30: lambda f: (f*(-802230 - 4660227*f - 16657212*f**2 - 41198378*f**3 - 74083110*f**4 - 96725325*f**5 - 85411444*f**6 - 38379264*f**7 + 11809854*f**8 + 31787595*f**9 + 23270940*f**10 + 9130968*f**11 + 1935648*f**12 + 175032*f**13))/6.04910592e11,
    31: lambda f: -(f*(3165162 + 15424695*f + 44399784*f**2 + 84582446*f**3 + 108333690*f**4 + 78297393*f**5 - 1466528*f**6 - 58996812*f**7 - 42706818*f**8 + 4481505*f**9 + 22957704*f**10 + 13937616*f**11 + 3747744*f**12 + 396396*f**13))/4.234374144e11,
}

Q120 = {
    0: lambda f: 0,
    1: lambda f: 0,
    2: lambda f: -(f*(14 + 19*f + 12*f**2 + 3*f**3))/42.,
    3: lambda f: 0,
    4: lambda f: (f*(42 + 93*f + 112*f**2 + 78*f**3 + 30*f**4 + 5*f**5))/252.,
    5: lambda f: 0,
    6: lambda f: -(f*(462 + 1419*f + 2508*f**2 + 2837*f**3 + 2110*f**4 + 1005*f**5 + 280*f**6 + 35*f**7))/11088.,
    7: lambda f: 0,
    8: lambda f: (f*(6006 + 23595*f + 54912*f**2 + 85748*f**3 + 94060*f**4 + 73170*f**5 + 39760*f**6 + 14420*f**7 + 3150*f**8 + 315*f**9))/864864.,
    9: lambda f: 0,
    10: lambda f: -(f*(30030 + 143715*f + 414700*f**2 + 825175*f**3 + 1194500*f**4 + 1300454*f**5 + 1078112*f**6 + 670390*f**7 + 300510*f**8 + 91035*f**9 + 16632*f**10 + 1386*f**11))/3.459456e7,
    11: lambda f: 0,
    12: lambda f: (f*(6006 + 33891*f + 116688*f**2 + 282022*f**3 + 506750*f**4 + 695829*f**5 + 716912*f**6 + 530740*f**7 + 269010*f**8 + 87885*f**9 + 16632*f**10 + 1386*f**11))/6.918912e7,
    13: lambda f: 0,
    14: lambda f: -(f*(858 + 5577*f + 22308*f**2 + 63427*f**3 + 136070*f**4 + 220761*f**5 + 258248*f**6 + 207835*f**7 + 110790*f**8 + 37215*f**9 + 7128*f**10 + 594*f**11))/1.1860992e8,
    15: lambda f: 0,
    16: lambda f: 0,
    17: lambda f: 0,
    18: lambda f: (5*f**2 - 3*f**4)/63.,
    19: lambda f: (f**2*(-23 - 6*f + 9*f**2))/126.,
    20: lambda f: (f*(14 - 3*f - 16*f**2 - 2*f**3 + 10*f**4 + 5*f**5))/252.,
    21: lambda f: (f*(-308 + 99*f + 484*f**2 + 210*f**3 - 120*f**4 - 85*f**5))/2772.,
    22: lambda f: -(f*(231 + 231*f - 66*f**2 - 263*f**3 - 65*f**4 + 165*f**5 + 140*f**6 + 35*f**7))/8316.,
    23: lambda f: (f*(24024 + 22737*f - 14586*f**2 - 42913*f**3 - 24340*f**4 + 5415*f**5 + 10150*f**6 + 2905*f**7))/432432.,
    24: lambda f: (f*(18018 + 35607*f + 27456*f**2 - 10140*f**3 - 31420*f**4 - 10470*f**5 + 18480*f**6 + 21700*f**7 + 9450*f**8 + 1575*f**9))/2.594592e6,
    25: lambda f: -(f*(36036 + 69927*f + 44616*f**2 - 48828*f**3 - 109760*f**4 - 71142*f**5 + 1176*f**6 + 26852*f**7 + 14364*f**8 + 2583*f**9))/2.594592e6,
    26: lambda f: -(f*(12012 + 34749*f + 51480*f**2 + 32305*f**3 - 15000*f**4 - 39702*f**5 - 15904*f**6 + 21210*f**7 + 31500*f**8 + 18585*f**9 + 5544*f**10 + 693*f**11))/1.0378368e7,
    27: lambda f: (f*(816816 + 2341053*f + 3281850*f**2 + 1424345*f**3 - 2682600*f**4 - 5136006*f**5 - 3617348*f**6 - 449190*f**7 + 1146600*f**8 + 910665*f**9 + 300762*f**10 + 39501*f**11))/3.52864512e8,
    28: lambda f: (f*(510510 + 1932645*f + 4084080*f**2 + 5007418*f**3 + 2708950*f**4 - 1551165*f**5 - 3648400*f**6 - 1659700*f**7 + 1732122*f**8 + 3121755*f**9 + 2254560*f**10 + 921690*f**11 + 210210*f**12 + 21021*f**13))/3.52864512e9,
    29: lambda f: -(f*(19399380 + 73024809*f + 150206628*f**2 + 168892178*f**3 + 46059800*f**4 - 164599185*f**5 - 282844184*f**6 - 210764708*f**7 - 48164508*f**8 + 53010615*f**9 + 58244340*f**10 + 27128178*f**11 + 6582576*f**12 + 681681*f**13))/6.704425728e10,
    30: lambda f: -(f*(43758 + 204204*f + 554268*f**2 + 962676*f**3 + 1037170*f**4 + 386580*f**5 - 668040*f**6 - 990100*f**7 - 175662*f**8 + 699120*f**9 + 764280*f**10 + 369765*f**11 + 90090*f**12 + 9009*f**13))/3.02455296e9,
    31: lambda f: (f*(23279256 + 108220827*f + 289050762*f**2 + 482780025*f**3 + 458847340*f**4 - 3221925*f**5 - 707700714*f**6 - 977179903*f**7 - 522976608*f**8 + 75210345*f**9 + 263748870*f**10 + 151511283*f**11 + 39495456*f**12 + 4090086*f**13))/8.0453108736e11,
}

Q122 = {
    0: lambda f: 0,
    1: lambda f: 0,
    2: lambda f: 0,
    3: lambda f: (-21 - 44*f - 58*f**2 - 36*f**3 - 9*f**4)/168.,
    4: lambda f: 0,
    5: lambda f: (231 + 726*f + 1551*f**2 + 1868*f**3 + 1317*f**4 + 510*f**5 + 85*f**6)/5544.,
    6: lambda f: 0,
    7: lambda f: (-9009 - 37752*f - 111540*f**2 - 198744*f**3 - 228766*f**4 - 172520*f**5 - 82980*f**6 - 23240*f**7 - 2905*f**8)/1.153152e6,
    8: lambda f: 0,
    9: lambda f: (9009 + 47190*f + 178035*f**2 + 419640*f**3 + 668810*f**4 + 746356*f**5 + 588390*f**6 + 322840*f**7 + 117845*f**8 + 25830*f**9 + 2583*f**10)/8.64864e6,
    10: lambda f: 0,
    11: lambda f: (-255255 - 1604460*f - 7365930*f**2 - 21591700*f**3 - 43936925*f**4 - 64830520*f**5 - 71694428*f**6 - 60174184*f**7 - 37759505*f**8 - 17031420*f**9 - 5179230*f**10 - 948024*f**11 - 79002*f**12)/2.35243008e9,
    12: lambda f: 0,
    13: lambda f: (21879 + 160446*f + 867867*f**2 + 3041844*f**3 + 7529011*f**4 + 13807706*f**5 + 19274679*f**6 + 20098232*f**7 + 14996485*f**8 + 7637490*f**9 + 2501793*f**10 + 474012*f**11 + 39501*f**12)/2.35243008e9,
    14: lambda f: 0,
    15: lambda f: (-153153 - 1283568*f - 7993128*f**2 - 32598384*f**3 - 95019596*f**4 - 208246192*f**5 - 343517496*f**6 - 406397488*f**7 - 329343350*f**8 - 176274000*f**9 - 59340456*f**10 - 11376288*f**11 - 948024*f**12)/2.2583328768e11,
    16: lambda f: 0,
    17: lambda f: 0,
    18: lambda f: (-105 - 226*f - 159*f**2 + 84*f**3 + 96*f**4)/5040.,
    19: lambda f: (-735 - 154*f + 381*f**2 + 108*f**3 - 198*f**4)/3528.,
    20: lambda f: (1155 + 3696*f + 6710*f**2 + 3892*f**3 - 1377*f**4 - 2580*f**5 - 880*f**6)/110880.,
    21: lambda f: (8085 + 10164*f + 2816*f**2 - 7556*f**3 - 3739*f**4 + 2720*f**5 + 1870*f**6)/77616.,
    22: lambda f: (-45045 - 191334*f - 532389*f**2 - 696072*f**3 - 395423*f**4 + 84250*f**5 + 260265*f**6 + 145460*f**7 + 29120*f**8)/1.729728e7,
    23: lambda f: (-315315 - 726726*f - 923637*f**2 - 183144*f**3 + 601429*f**4 + 426490*f**5 - 125655*f**6 - 220780*f**7 - 63910*f**8)/1.2108096e7,
    24: lambda f: (45045 + 238524*f + 880308*f**2 + 1729416*f**3 + 1971574*f**4 + 1114560*f**5 - 123660*f**6 - 697480*f**7 - 515235*f**8 - 177660*f**9 - 25200*f**10)/1.0378368e8,
    25: lambda f: (315315 + 1057056*f + 2277990*f**2 + 2315352*f**3 + 435778*f**4 - 1403208*f**5 - 1214280*f**6 + 43400*f**7 + 563955*f**8 + 309960*f**9 + 56826*f**10)/7.2648576e7,
    26: lambda f: (-765765 - 4857138*f - 22192599*f**2 - 57535140*f**3 - 94733010*f**4 - 98980460*f**5 - 56374542*f**6 + 1780464*f**7 + 32945255*f**8 + 29426670*f**9 + 13592565*f**10 + 3428964*f**11 + 376992*f**12)/1.411458048e10,
    27: lambda f: (-5360355 - 23585562*f - 70939011*f**2 - 119512380*f**3 - 107274420*f**4 - 20444540*f**5 + 60012042*f**6 + 60048576*f**7 + 8895845*f**8 - 22754970*f**9 - 19007415*f**10 - 6478164*f**11 - 869022*f**12)/9.880206336e9,
    28: lambda f: (14549535 + 107527992*f + 583921338*f**2 + 1871359932*f**3 + 3982096133*f**4 + 5826978140*f**5 + 5750965068*f**6 + 3311546392*f**7 + 107283673*f**8 - 1791408528*f**9 - 1849989750*f**10 - 1036080276*f**11 - 356197149*f**12 - 71147076*f**13 - 6390384*f**14)/2.6817702912e12,
    29: lambda f: (101846745 + 554822268*f + 2134486068*f**2 + 4927593684*f**3 + 7103828471*f**4 + 5860137320*f**5 + 1181361822*f**6 - 3029228888*f**7 - 3398897369*f**8 - 987155316*f**9 + 959027160*f**10 + 1162797636*f**11 + 567065961*f**12 + 141789648*f**13 + 14996982*f**14)/1.87723920384e12,
    30: lambda f: (-14549535 - 122770362*f - 771125355*f**2 - 2936007984*f**3 - 7623438571*f**4 - 14165685030*f**5 - 18834674103*f**6 - 16575743492*f**7 - 6845768013*f**8 + 3509533818*f**9 + 7388849475*f**10 + 5239226916*f**11 + 2029740174*f**12 + 426882456*f**13 + 38342304*f**14)/3.21812434944e13,
    31: lambda f: (-101846745 - 661518858*f - 3095725347*f**2 - 9018242688*f**3 - 17468773147*f**4 - 22541333430*f**5 - 15879893967*f**6 + 1850844268*f**7 + 14524563039*f**8 + 10405756746*f**9 - 704145645*f**10 - 5130509076*f**11 - 3154724496*f**12 - 850737888*f**13 - 89981892*f**14)/2.252687044608e13,
}

Q000 = {
    0: lambda f: (-3 - 2*f - f**2)/6.,
    1: lambda f: 0,
    2: lambda f: (15 + 20*f + 22*f**2 + 12*f**3 + 3*f**4)/120.,
    3: lambda f: 0,
    4: lambda f: (-35 - 70*f - 119*f**2 - 124*f**3 - 81*f**4 - 30*f**5 - 5*f**6)/1680.,
    5: lambda f: 0,
    6: lambda f: (0.125 + (f*(2 + f))/6. + (3*f**2*(2 + f)**2)/20. + (f**3*(2 + f)**3)/14. + (f**4*(2 + f)**4)/72.)/48.,
    7: lambda f: 0,
    8: lambda f: (-0.0625 - (5*f*(2 + f))/48. - (f**2*(2 + f)**2)/8. - (5*f**3*(2 + f)**3)/56. - (5*f**4*(2 + f)**4)/144. - (f**5*(2 + f)**5)/176.)/240.,
    9: lambda f: 0,
    10: lambda f: (0.03125 + (f*(2 + f))/16. + (3*f**2*(2 + f)**2)/32. + (5*f**3*(2 + f)**3)/56. + (5*f**4*(2 + f)**4)/96. + (3*f**5*(2 + f)**5)/176.)/1440.,
    11: lambda f: 0,
    12: lambda f: (-495 - 1155*f*(2 + f) - 2079*f**2*(2 + f)**2 - 2475*f**3*(2 + f)**3 - 1925*f**4*(2 + f)**4 - 945*f**5*(2 + f)**5)/3.193344e8,
    13: lambda f: 0,
    14: lambda f: (0.0078125 + (f*(2 + f))/48. + (7*f**2*(2 + f)**2)/160. + (f**3*(2 + f)**3)/16. + (35*f**4*(2 + f)**4)/576. + (7*f**5*(2 + f)**5)/176.)/80640.,
    15: lambda f: 0,
    16: lambda f: (-3 + 2*f - f**2)/18.,
    17: lambda f: (15 - 10*f + 2*f**2)/45.,
    18: lambda f: (15 - 2*f**2 + 3*f**4)/180.,
    19: lambda f: (-105 + 35*f**2 + 18*f**3 - 12*f**4)/630.,
    20: lambda f: (-105 - 70*f - 21*f**2 + 36*f**3 - 3*f**4 - 30*f**5 - 15*f**6)/5040.,
    21: lambda f: (105 + 70*f - 72*f**3 - 35*f**4 + 10*f**5 + 10*f**6)/2520.,
    22: lambda f: (315 + 420*f + 420*f**2 + 36*f**3 - 182*f**4 - 20*f**5 + 180*f**6 + 140*f**7 + 35*f**8)/90720.,
    23: lambda f: (-3465 - 4620*f - 3927*f**2 + 1386*f**3 + 4873*f**4 + 3040*f**5 - 225*f**6 - 910*f**7 - 280*f**8)/498960.,
    24: lambda f: (-3465 - 6930*f - 11319*f**2 - 8712*f**3 - 330*f**4 + 4580*f**5 + 930*f**6 - 4200*f**7 - 4445*f**8 - 1890*f**9 - 315*f**10)/7.98336e6,
    25: lambda f: (45045 + 90090*f + 138138*f**2 + 82368*f**3 - 62634*f**4 - 154700*f**5 - 105600*f**6 - 8400*f**7 + 29645*f**8 + 17010*f**9 + 3150*f**10)/5.189184e7,
    26: lambda f: (9009 + 24024*f + 54054*f**2 + 72072*f**3 + 49907*f**4 - 1872*f**5 - 29532*f**6 - 8624*f**7 + 25095*f**8 + 32760*f**9 + 18774*f**10 + 5544*f**11 + 693*f**12)/2.0756736e8,
    27: lambda f: (-45045 - 120120*f - 261261*f**2 - 321750*f**3 - 144430*f**4 + 204360*f**5 + 408510*f**6 + 298396*f**7 + 57015*f**8 - 70560*f**9 - 61425*f**10 - 20790*f**11 - 2772*f**12)/5.189184e8,
    28: lambda f: (-45045 - 150150*f - 429429*f**2 - 797940*f**3 - 947089*f**4 - 586690*f**5 + 286335*f**6 + 677320*f**7 + 13825*f**8 - 614250*f**9 - 501795*f**10 - 166320*f**11 - 20790*f**12)/1.24540416e10,
    29: lambda f: (45045 + 150150*f + 420420*f**2 + 751608*f**3 + 795223*f**4 + 239590*f**5 - 872910*f**6 - 1427776*f**7 - 713965*f**8 + 168210*f**9 + 321300*f**10 + 124740*f**11 + 16632*f**12)/6.2270208e9,
    30: lambda f: (6435 + 25740*f + 89232*f**2 + 211068*f**3 + 344916*f**4 + 369980*f**5 - 13200*f**6 - 375060*f**7 - 126350*f**8 + 245700*f**9 + 240660*f**10 + 83160*f**11 + 10395*f**12)/2.49080832e10,
    31: lambda f: (-6435 - 25740*f - 87945*f**2 - 203346*f**3 - 315315*f**4 - 289640*f**5 + 177135*f**6 + 633738*f**7 + 412895*f**8 - 41580*f**9 - 152775*f**10 - 62370*f**11 - 8316*f**12)/1.24540416e10,
}

Q002 = {
    0: lambda f: 0,
    1: lambda f: -(f*(2 + f))/15.,
    2: lambda f: 0,
    3: lambda f: (f*(14 + 19*f + 12*f**2 + 3*f**3))/210.,
    4: lambda f: 0,
    5: lambda f: -(f*(42 + 93*f + 112*f**2 + 78*f**3 + 30*f**4 + 5*f**5))/2520.,
    6: lambda f: 0,
    7: lambda f: (f*(462 + 1419*f + 2508*f**2 + 2837*f**3 + 2110*f**4 + 1005*f**5 + 280*f**6 + 35*f**7))/166320.,
    8: lambda f: 0,
    9: lambda f: -(f*(6006 + 23595*f + 54912*f**2 + 85748*f**3 + 94060*f**4 + 73170*f**5 + 39760*f**6 + 14420*f**7 + 3150*f**8 + 315*f**9))/1.729728e7,
    10: lambda f: 0,
    11: lambda f: (f*(6006 + 28743*f + 82940*f**2 + 165035*f**3 + 238900*f**4 + 242350*f**5 + 162400*f**6 + 67550*f**7 + 15750*f**8 + 1575*f**9))/1.729728e8,
    12: lambda f: 0,
    13: lambda f: -(f*(6006 + 33891*f + 116688*f**2 + 282022*f**3 + 506750*f**4 + 607125*f**5 + 450800*f**6 + 198100*f**7 + 47250*f**8 + 4725*f**9))/2.0756736e9,
    14: lambda f: 0,
    15: lambda f: (f*(858 + 5577*f + 22308*f**2 + 63427*f**3 + 136070*f**4 + 182745*f**5 + 144200*f**6 + 65275*f**7 + 15750*f**8 + 1575*f**9))/4.1513472e9,
    16: lambda f: ((-2 + f)*f)/45.,
    17: lambda f: ((28 - 11*f)*f)/315.,
    18: lambda f: (f*(350 + 159*f - 36*f**2 - 84*f**3))/12600.,
    19: lambda f: (f*(98 - 273*f - 72*f**2 + 132*f**3))/8820.,
    20: lambda f: (f*(-210 - 289*f - 184*f**2 + 29*f**3 + 80*f**4 + 30*f**5))/25200.,
    21: lambda f: -(f*(294 + 70*f - 212*f**2 - 103*f**3 + 80*f**4 + 55*f**5))/17640.,
    22: lambda f: (f*(16170 + 36861*f + 46596*f**2 + 27034*f**3 - 1370*f**4 - 12675*f**5 - 7420*f**6 - 1540*f**7))/9.9792e6,
    23: lambda f: (f*(35574 + 45969*f + 11352*f**2 - 26882*f**3 - 18950*f**4 + 6585*f**5 + 10640*f**6 + 3080*f**7))/6.98544e6,
    24: lambda f: (f*(-60060 - 190476*f - 353496*f**2 - 389129*f**3 - 228510*f**4 - 4035*f**5 + 103460*f**6 + 80745*f**7 + 28350*f**8 + 4095*f**9))/2.594592e8,
    25: lambda f: -(f*(336336 + 747747*f + 779064*f**2 + 189046*f**3 - 385020*f**4 - 339960*f**5 + 27440*f**6 + 174930*f**7 + 94500*f**8 + 17325*f**9))/3.6324288e8,
    26: lambda f: (f*(54054 + 219219*f + 533676*f**2 + 839904*f**3 + 862780*f**4 + 508914*f**5 + 38136*f**6 - 219940*f**7 - 208530*f**8 - 97965*f**9 - 24948*f**10 - 2772*f**11))/2.0756736e9,
    27: lambda f: (f*(882882 + 2753751*f + 4650360*f**2 + 4218240*f**3 + 1063700*f**4 - 1857462*f**5 - 1932336*f**6 - 216020*f**7 + 830970*f**8 + 671895*f**9 + 227304*f**10 + 30492*f**11))/7.2648576e9,
    28: lambda f: (f*(-150150 - 740883*f - 2227368*f**2 - 4517617*f**3 - 6423100*f**4 - 6057960*f**5 - 2711240*f**6 + 1076950*f**7 + 2277450*f**8 + 1346625*f**9 + 374220*f**10 + 41580*f**11))/6.2270208e10,
    29: lambda f: -(f*(546546 + 2186184*f + 5012436*f**2 + 7157059*f**3 + 5988100*f**4 + 29139*f**5 - 4825408*f**6 - 2871610*f**7 + 1075410*f**8 + 1755810*f**9 + 681912*f**10 + 91476*f**11))/4.35891456e10,
    30: lambda f: (f*(47190 + 274131*f + 979836*f**2 + 2423434*f**3 + 4357830*f**4 + 5309565*f**5 + 3263540*f**6 - 369600*f**7 - 1993950*f**8 - 1305675*f**9 - 374220*f**10 - 41580*f**11))/2.49080832e11,
    31: lambda f: (f*(186186 + 907335*f + 2611752*f**2 + 4975438*f**3 + 6372570*f**4 + 1944609*f**5 - 4271008*f**6 - 3546060*f**7 + 602910*f**8 + 1669185*f**9 + 681912*f**10 + 91476*f**11))/1.743565824e11,
}

Q020 = {
    0: lambda f: -(f*(2 + f))/3.,
    1: lambda f: 0,
    2: lambda f: (f*(14 + 19*f + 12*f**2 + 3*f**3))/42.,
    3: lambda f: 0,
    4: lambda f: -(f*(42 + 93*f + 112*f**2 + 78*f**3 + 30*f**4 + 5*f**5))/504.,
    5: lambda f: 0,
    6: lambda f: (f*(462 + 1419*f + 2508*f**2 + 2837*f**3 + 2110*f**4 + 1005*f**5 + 280*f**6 + 35*f**7))/33264.,
    7: lambda f: 0,
    8: lambda f: -(f*(6006 + 23595*f + 54912*f**2 + 85748*f**3 + 94060*f**4 + 73170*f**5 + 39760*f**6 + 14420*f**7 + 3150*f**8 + 315*f**9))/3.459456e6,
    9: lambda f: 0,
    10: lambda f: (f*(6006 + 28743*f + 82940*f**2 + 165035*f**3 + 238900*f**4 + 242350*f**5 + 162400*f**6 + 67550*f**7 + 15750*f**8 + 1575*f**9))/3.459456e7,
    11: lambda f: 0,
    12: lambda f: -(f*(6006 + 33891*f + 116688*f**2 + 282022*f**3 + 506750*f**4 + 607125*f**5 + 450800*f**6 + 198100*f**7 + 47250*f**8 + 4725*f**9))/4.1513472e8,
    13: lambda f: 0,
    14: lambda f: (f*(858 + 5577*f + 22308*f**2 + 63427*f**3 + 136070*f**4 + 182745*f**5 + 144200*f**6 + 65275*f**7 + 15750*f**8 + 1575*f**9))/8.3026944e8,
    15: lambda f: 0,
    16: lambda f: -((-2 + f)*f)/9.,
    17: lambda f: (f*(-28 + 11*f))/63.,
    18: lambda f: (f**2*(-5 + 3*f**2))/63.,
    19: lambda f: (f**2*(23 + 6*f - 9*f**2))/126.,
    20: lambda f: (f*(-14 + 3*f + 16*f**2 + 2*f**3 - 10*f**4 - 5*f**5))/504.,
    21: lambda f: (f*(308 - 99*f - 484*f**2 - 210*f**3 + 120*f**4 + 85*f**5))/5544.,
    22: lambda f: (f*(231 + 231*f - 66*f**2 - 263*f**3 - 65*f**4 + 165*f**5 + 140*f**6 + 35*f**7))/24948.,
    23: lambda f: -(f*(24024 + 22737*f - 14586*f**2 - 42913*f**3 - 24340*f**4 + 5415*f**5 + 10150*f**6 + 2905*f**7))/1.297296e6,
    24: lambda f: -(f*(18018 + 35607*f + 27456*f**2 - 10140*f**3 - 31420*f**4 - 10470*f**5 + 18480*f**6 + 21700*f**7 + 9450*f**8 + 1575*f**9))/1.0378368e7,
    25: lambda f: (f*(36036 + 69927*f + 44616*f**2 - 48828*f**3 - 109760*f**4 - 71142*f**5 + 1176*f**6 + 26852*f**7 + 14364*f**8 + 2583*f**9))/1.0378368e7,
    26: lambda f: (f*(12012 + 34749*f + 51480*f**2 + 32305*f**3 - 15000*f**4 - 39702*f**5 - 15904*f**6 + 21210*f**7 + 31500*f**8 + 18585*f**9 + 5544*f**10 + 693*f**11))/5.189184e7,
    27: lambda f: -(f*(816816 + 2341053*f + 3281850*f**2 + 1424345*f**3 - 2682600*f**4 - 5136006*f**5 - 3617348*f**6 - 449190*f**7 + 1146600*f**8 + 910665*f**9 + 300762*f**10 + 39501*f**11))/1.76432256e9,
    28: lambda f: -(f*(30030 + 113685*f + 240240*f**2 + 294554*f**3 + 159350*f**4 - 179949*f**5 - 322448*f**6 - 34580*f**7 + 236250*f**8 + 199395*f**9 + 66528*f**10 + 8316*f**11))/1.24540416e9,
    29: lambda f: (f*(1021020 + 3843411*f + 7905612*f**2 + 8889062*f**3 + 2424200*f**4 - 11679051*f**5 - 18552968*f**6 - 8554700*f**7 + 3216780*f**8 + 4805325*f**9 + 1804572*f**10 + 237006*f**11))/2.117187072e10,
    30: lambda f: (f*(2574 + 12012*f + 32604*f**2 + 56628*f**3 + 61010*f**4 - 15276*f**5 - 85512*f**6 - 31220*f**7 + 47250*f**8 + 47880*f**9 + 16632*f**10 + 2079*f**11))/1.24540416e9,
    31: lambda f: -(f*(1225224 + 5695833*f + 15213198*f**2 + 25409475*f**3 + 24149860*f**4 - 18265191*f**5 - 59245998*f**6 - 36201445*f**7 + 6985440*f**8 + 16050195*f**9 + 6316002*f**10 + 829521*f**11))/2.9640619008e11,
}

Q022 = {
    0: lambda f: 0,
    1: lambda f: (-21 - 22*f - 11*f**2)/42.,
    2: lambda f: 0,
    3: lambda f: (21 + 44*f + 58*f**2 + 36*f**3 + 9*f**4)/168.,
    4: lambda f: 0,
    5: lambda f: (-231 - 726*f - 1551*f**2 - 1868*f**3 - 1317*f**4 - 510*f**5 - 85*f**6)/11088.,
    6: lambda f: 0,
    7: lambda f: (9009 + 37752*f + 111540*f**2 + 198744*f**3 + 228766*f**4 + 172520*f**5 + 82980*f**6 + 23240*f**7 + 2905*f**8)/3.459456e6,
    8: lambda f: 0,
    9: lambda f: (-9009 - 47190*f - 178035*f**2 - 419640*f**3 - 668810*f**4 - 746356*f**5 - 588390*f**6 - 322840*f**7 - 117845*f**8 - 25830*f**9 - 2583*f**10)/3.459456e7,
    10: lambda f: 0,
    11: lambda f: (3003 + 18876*f + 86658*f**2 + 254020*f**3 + 516905*f**4 + 762712*f**5 + 783980*f**6 + 529480*f**7 + 221165*f**8 + 51660*f**9 + 5166*f**10)/1.3837824e8,
    12: lambda f: 0,
    13: lambda f: (-1287 - 9438*f - 51051*f**2 - 178932*f**3 - 442883*f**4 - 812218*f**5 - 985095*f**6 - 736120*f**7 - 324485*f**8 - 77490*f**9 - 7749*f**10)/8.3026944e8,
    14: lambda f: 0,
    15: lambda f: (9009 + 75504*f + 470184*f**2 + 1917552*f**3 + 5589388*f**4 + 12249776*f**5 + 16637880*f**6 + 13198640*f**7 + 5989270*f**8 + 1446480*f**9 + 144648*f**10)/9.299017728e10,
    16: lambda f: -0.041666666666666664 - (29*f)/630. + (2*f**2)/45.,
    17: lambda f: (-735 + 616*f - 242*f**2)/1764.,
    18: lambda f: (105 + 226*f + 159*f**2 - 84*f**3 - 96*f**4)/5040.,
    19: lambda f: (735 + 154*f - 381*f**2 - 108*f**3 + 198*f**4)/3528.,
    20: lambda f: (-1155 - 3696*f - 6710*f**2 - 3892*f**3 + 1377*f**4 + 2580*f**5 + 880*f**6)/221760.,
    21: lambda f: (-8085 - 10164*f - 2816*f**2 + 7556*f**3 + 3739*f**4 - 2720*f**5 - 1870*f**6)/155232.,
    22: lambda f: (45045 + 191334*f + 532389*f**2 + 696072*f**3 + 395423*f**4 - 84250*f**5 - 260265*f**6 - 145460*f**7 - 29120*f**8)/5.189184e7,
    23: lambda f: (315315 + 726726*f + 923637*f**2 + 183144*f**3 - 601429*f**4 - 426490*f**5 + 125655*f**6 + 220780*f**7 + 63910*f**8)/3.6324288e7,
    24: lambda f: (-45045 - 238524*f - 880308*f**2 - 1729416*f**3 - 1971574*f**4 - 1114560*f**5 + 123660*f**6 + 697480*f**7 + 515235*f**8 + 177660*f**9 + 25200*f**10)/4.1513472e8,
    25: lambda f: (-315315 - 1057056*f - 2277990*f**2 - 2315352*f**3 - 435778*f**4 + 1403208*f**5 + 1214280*f**6 - 43400*f**7 - 563955*f**8 - 309960*f**9 - 56826*f**10)/2.90594304e8,
    26: lambda f: (765765 + 4857138*f + 22192599*f**2 + 57535140*f**3 + 94733010*f**4 + 98980460*f**5 + 56374542*f**6 - 1780464*f**7 - 32945255*f**8 - 29426670*f**9 - 13592565*f**10 - 3428964*f**11 - 376992*f**12)/7.05729024e10,
    27: lambda f: (5360355 + 23585562*f + 70939011*f**2 + 119512380*f**3 + 107274420*f**4 + 20444540*f**5 - 60012042*f**6 - 60048576*f**7 - 8895845*f**8 + 22754970*f**9 + 19007415*f**10 + 6478164*f**11 + 869022*f**12)/4.940103168e10,
    28: lambda f: (-765765 - 5659368*f - 30732702*f**2 - 98492628*f**3 - 209584007*f**4 - 306683060*f**5 - 290042052*f**6 - 117718216*f**7 + 76187405*f**8 + 131256720*f**9 + 75129390*f**10 + 20573784*f**11 + 2261952*f**12)/8.468748288e11,
    29: lambda f: (-5360355 - 29201172*f - 112341372*f**2 - 259347036*f**3 - 373885709*f**4 - 308428280*f**5 + 26305302*f**6 + 296293256*f**7 + 175454195*f**8 - 57490020*f**9 - 99553860*f**10 - 38868984*f**11 - 5214132*f**12)/5.9281238016e11,
    30: lambda f: (765765 + 6461598*f + 40585545*f**2 + 154526736*f**3 + 401233609*f**4 + 745562370*f**5 + 915456717*f**6 + 532965356*f**7 - 130699905*f**8 - 406544670*f**9 - 255455865*f**10 - 72008244*f**11 - 7916832*f**12)/1.18562476032e13,
    31: lambda f: (5360355 + 34816782*f + 162932913*f**2 + 474644352*f**3 + 919409113*f**4 + 1186385970*f**5 + 304890453*f**6 - 918573796*f**7 - 743839845*f**8 + 109001970*f**9 + 331532775*f**10 + 136041444*f**11 + 18249462*f**12)/8.29937332224e12,
}

Qa = {
    0: {
        0: { 0: Q000, 2: Q002 },
        2: { 0: Q020, 2: Q022 }
    },
    1: {
        0: { 0: Q100, 2: Q102 },
        2: { 0: Q120, 2: Q122 }
    },
}

kout = np.array([ 0.001, 0.005, 0.0075, 0.01, 0.0125, 0.015, 0.0175, 0.02, 0.025, 0.03, 0.035, 0.04, 0.045, 0.05, 0.055, 0.06, 0.065, 0.07, 0.075, 0.08, 0.085, 0.09, 0.095, 0.1, 0.105, 0.11, 0.115, 0.12, 0.125, 0.13, 0.135, 0.14, 0.145, 0.15, 0.155, 0.16, 0.17, 0.18, 0.19, 0.2, 0.21, 0.22, 0.23, 0.24, 0.25, 0.26, 0.27, 0.28, 0.29, 0.3 ])
qopti = np.array([ 5.000e+01,5.245e+01,5.490e+01,5.735e+01,5.980e+01,6.224e+01,6.469e+01,6.714e+01,6.959e+01,7.204e+01,7.449e+01,7.694e+01,7.939e+01,8.184e+01,8.429e+01,8.673e+01,8.918e+01,9.163e+01,9.408e+01,9.653e+01,9.898e+01,1.014e+02,1.039e+02,1.063e+02,1.088e+02,1.112e+02,1.137e+02,1.161e+02,1.186e+02,1.210e+02,1.235e+02,1.259e+02,1.284e+02,1.308e+02,1.333e+02,1.357e+02,1.382e+02,1.406e+02,1.431e+02,1.455e+02,1.480e+02,1.504e+02,1.529e+02,1.553e+02,1.578e+02,1.602e+02,1.627e+02,1.651e+02,1.676e+02,1.700e+02 ])
qEH = np.array([  1.000e+00,1.124e+00,1.264e+00,1.421e+00,1.597e+00,1.796e+00,2.019e+00,2.270e+00,2.551e+00,2.868e+00,3.225e+00,3.625e+00,4.075e+00,4.582e+00,5.151e+00,5.790e+00,6.510e+00,7.318e+00,8.227e+00,9.249e+00,1.040e+01,1.169e+01,1.314e+01,1.477e+01,1.661e+01,1.867e+01,2.099e+01,2.360e+01,2.653e+01,2.982e+01,3.353e+01,3.769e+01,4.238e+01,4.764e+01,5.356e+01,6.000e+01,6.021e+01,6.526e+01,6.769e+01,7.053e+01,7.579e+01,7.609e+01,8.105e+01,8.555e+01,8.632e+01,9.158e+01,9.617e+01,9.684e+01,1.021e+02,1.074e+02,1.081e+02,1.126e+02,1.179e+02,1.215e+02,1.232e+02,1.284e+02,1.337e+02,1.366e+02,1.389e+02,1.442e+02,1.495e+02,1.536e+02,1.547e+02,1.600e+02,1.727e+02,1.941e+02,2.183e+02,2.454e+02,2.759e+02,3.101e+02,3.486e+02,3.919e+02,4.406e+02,4.954e+02,5.569e+02,6.261e+02,7.038e+02,7.912e+02,8.895e+02,1.000e+03])

class Common(object):
    def __init__(self, Nl=2, kmin=0.001, kmax=0.5):
        
        self.Nl = Nl
        self.N11 = 3
        self.Nct = 6
        self.N22 = 28 # number of 22-loops
        self.N13 = 10 # number of 13-loops
        self.Nloop = 12 # number of bias-independent loops
        self.k = kout #np.arange(kmin, kmax, 0.01)
        self.Nk = self.k.shape[0]
        self.s = qEH
        self.Ns = self.s.shape[0]
        self.kr = self.k[0.02<=self.k]
        self.Nkr = self.kr.shape[0]
        self.Nklow = self.Nk-self.Nkr
        
        self.l11 = np.empty(shape=(self.Nl, self.N11))
        self.lct = np.empty(shape=(self.Nl, self.Nct))
        self.l22 = np.empty(shape=(self.Nl, self.N22))
        self.l13 = np.empty(shape=(self.Nl, self.N13))
        
        for i in range(self.Nl):
            l = 2*i
            self.l11[i] = np.array([ mu[0][l], mu[2][l], mu[4][l] ])
            self.lct[i] = np.array([ mu[0][l], mu[2][l], mu[4][l], mu[2][l], mu[4][l], mu[6][l] ])
            self.l22[i] = np.array([ 6*[mu[0][l]] + 7*[mu[2][l]] + [mu[4][l], mu[2][l], mu[4][l], mu[2][l], mu[4][l], mu[2][l]] + 3*[mu[4][l]] + [mu[6][l], mu[4][l], mu[6][l], mu[4][l], mu[6][l], mu[8][l]] ])
            self.l13[i] = np.array([ 2*[mu[0][l]] + 4*[mu[2][l]] + 3*[mu[4][l]] + [mu[6][l]] ])
        
        # self.sLow = 70.
        # self.sHigh = 190.
        # self.idlow = np.where(self.s>self.sLow)[0][0]
        # self.idhigh = np.where(self.s>self.sHigh)[0][0]

        # self.sbao = self.s[self.idlow:self.idhigh]
        # self.snobao = np.concatenate([self.s[:self.idlow], self.s[self.idhigh:]])
        
        # self.sr = self.sbao
        self.sr = self.s
        
common = Common()

class Bird(object):
    def __init__(self, kin, Plin, Omega_m, z, full=True, marg=False, co=common):
        self.full = full
        self.f = fN(Omega_m, z)
        self.kin = kin
        self.Pin = Plin
        self.Plin = interp1d(kin, Plin, kind='cubic')
        self.P11 = self.Plin(co.k)
        self.P22 = np.empty(shape=(co.N22, co.Nk))
        self.P13 = np.empty(shape=(co.N13, co.Nk))

        if marg is True:
            full = False
            self.Pctl = np.empty(shape=(co.Nl, co.Nct, co.Nk))
            self.P13l = np.empty(shape=(co.Nl, co.N13, co.Nk))
            self.Pb3 = np.empty(shape=(co.Nl, co.Nk))
            self.Cb3 = np.empty(shape=(co.Nl, co.Ns))
        
        if full is False:
            self.Ploopl = np.empty(shape=(co.Nl, co.Nloop, co.Nk))
            self.Cloopl = np.empty(shape=(co.Nl, co.Nloop, co.Ns))
            self.P11l = np.empty(shape=(co.Nl, co.N11, co.Nk))
            self.Pctl = np.empty(shape=(co.Nl, co.Nct, co.Nk))
            self.P22l = np.empty(shape=(co.Nl, co.N22, co.Nk))
            self.P13l = np.empty(shape=(co.Nl, co.N13, co.Nk))
        
        self.C11 = np.empty(shape=(co.Nl, co.Ns))
        self.C22 = np.empty(shape=(co.Nl, co.N22, co.Ns))
        self.C13 = np.empty(shape=(co.Nl, co.N13, co.Ns))
        self.Cct = np.empty(shape=(co.Nl, co.Ns))
        self.b11 = np.empty(shape=(co.Nl))
        self.b13 = np.empty(shape=(co.Nl, co.N13))
        self.b22 = np.empty(shape=(co.Nl, co.N22))
        self.bct = np.empty(shape=(co.Nl))
        self.Ps = np.empty(shape=(2, co.Nl, co.Nk))
        self.Cf = np.empty(shape=(2, co.Nl, co.Ns))
        self.fullPs = np.empty(shape=(co.Nl, co.Nk))
    
    def setBias(self, bs, co=common):
        b1, b2, b3, b4, b5, b6, b7 = bs
        f = self.f
        for i in range(co.Nl):
            l = 2*i
            self.b11[i] = b1**2*mu[0][l] + 2.*b1*f*mu[2][l] + f**2*mu[4][l]
            self.b22[i] = np.array([ b1**2*mu[0][l], b1*b2*mu[0][l], b1*b4*mu[0][l], b2**2*mu[0][l], b2*b4*mu[0][l], b4**2*mu[0][l], b1**2*f*mu[2][l], b1*b2*f*mu[2][l], b1*b4*f*mu[2][l], b1*f*mu[2][l], b2*f*mu[2][l], b4*f*mu[2][l], b1**2*f**2*mu[2][l], b1**2*f**2*mu[4][l], b1*f**2*mu[2][l], b1*f**2*mu[4][l], b2*f**2*mu[2][l], b2*f**2*mu[4][l], b4*f**2*mu[2][l], b4*f**2*mu[4][l], f**2*mu[4][l], b1*f**3*mu[4][l], b1*f**3*mu[6][l], f**3*mu[4][l], f**3*mu[6][l], f**4*mu[4][l], f**4*mu[6][l], f**4*mu[8][l] ])
            self.b13[i] = np.array([ b1**2*mu[0][l], b1*b3*mu[0][l], b1**2*f*mu[2][l], b1*f*mu[2][l], b3*f*mu[2][l], b1*f**2*mu[2][l], b1*f**2*mu[4][l], f**2*mu[4][l], f**3*mu[4][l], f**3*mu[6][l] ])
            self.bct[i] = 2.*b1*(b5*mu[0][l]+b6*mu[2][l]+b7*mu[4][l]) + 2.*f*(b5*mu[2][l]+b6*mu[4][l]+b7*mu[6][l])
            
    def setPs(self, bs, co=common):
        self.setBias(bs, co=co)
        self.Ps[0] = np.einsum('l,x->lx', self.b11, self.P11)
        self.Ps[1] = np.einsum('lb,bx->lx', self.b22, self.P22)
        for l in range(co.Nl): self.Ps[1,l] -= self.Ps[1,l,0]
        self.Ps[1] += np.einsum('lb,bx->lx', self.b13, self.P13) + np.einsum('l,x,x->lx', self.bct, co.k**2, self.P11)
    
    def setCf(self, bs, co=common):
        self.setBias(bs, co=co)
        self.Cf[0] = np.einsum('l,lx->lx', self.b11, self.C11)
        self.Cf[1] = np.einsum('lb,lbx->lx', self.b22, self.C22) + np.einsum('lb,lbx->lx', self.b13, self.C13) + np.einsum('l,lx->lx', self.bct, self.Cct)

    def setPsCf(self, bs, co=common):
        self.setBias(bs, co=co)
        self.Ps[0] = np.einsum('l,x->lx', self.b11, self.P11)
        self.Ps[1] = np.einsum('lb,bx->lx', self.b22, self.P22)
        for l in range(co.Nl): self.Ps[1,l] -= self.Ps[1,l,0]
        self.Ps[1] += np.einsum('lb,bx->lx', self.b13, self.P13) + np.einsum('l,x,x->lx', self.bct, co.k**2, self.P11)
        self.Cf[0] = np.einsum('l,lx->lx', self.b11, self.C11)
        self.Cf[1] = np.einsum('lb,lbx->lx', self.b22, self.C22) + np.einsum('lb,lbx->lx', self.b13, self.C13) + np.einsum('l,lx->lx', self.bct, self.Cct)
    
    def setfullPs(self):
        self.fullPs = np.sum(self.Ps, axis=0)
    
    def setPsCfl(self, co=common):
        self.P11l = np.einsum('x,ln->lnx', self.P11, co.l11)
        self.Pctl = np.einsum('x,x,ln->lnx', co.k**2, self.P11, co.lct)
        self.P22l = np.einsum('nx,ln->lnx', self.P22, co.l22)
        self.P13l = np.einsum('nx,ln->lnx', self.P13, co.l13)
        
        self.C22 = np.einsum('lnx,ln->lnx', self.C22, co.l22)
        self.C13 = np.einsum('lnx,ln->lnx', self.C13, co.l13)
        
        self.reducePsCfl()
    
    # DEPRECIATED
    # def setPslb(self, bs, co=common):
    #     b1, b2, b3, b4, b5, b6, b7 = bs
    #     f = self.f
        
    #     b11 = np.array([ b1**2, 2.*b1*f, f**2 ])
    #     bct = np.array([ 2.*b1*b5, 2.*b1*b6, 2.*b1*b7, 2.*f*b5, 2.*f*b6, 2.*f*b7 ])
    #     b22 = np.array([ b1**2, b1*b2, b1*b4, b2**2, b2*b4, b4**2, b1**2*f, b1*b2*f, b1*b4*f, b1*f, b2*f, b4*f, b1**2*f**2, b1**2*f**2, b1*f**2, b1*f**2, b2*f**2, b2*f**2, b4*f**2, b4*f**2, f**2, b1*f**3, b1*f**3, f**3, f**3, f**4, f**4, f**4 ])
    #     b13 = np.array([ b1**2, b1*b3, b1**2*f, b1*f, b3*f, b1*f**2, b1*f**2, f**2, f**3, f**3 ])
        
    #     self.Ps[0] = np.einsum('b,lbx->lx', b11, self.P11l)
    #     self.Ps[1] = np.einsum('b,lbx->lx', b22, self.P22l)
    #     for l in range(co.Nl): self.Ps[1,l] -= self.Ps[1,l,0]
    #     self.Ps[1] += np.einsum('b,lbx->lx', b13, self.P13l) + np.einsum('b,lbx->lx', bct, self.Pctl)
    #     self.setfullPs()
        
    def reducePsCfl(self):
        f1 = self.f
        
        self.Ploopl[:,0] = f1**2*self.P22l[:,20] + f1**3*self.P22l[:,23] + f1**3*self.P22l[:,24] + f1**4*self.P22l[:,25] + f1**4*self.P22l[:,26] + f1**4*self.P22l[:,27] + f1**2*self.P13l[:,7] + f1**3*self.P13l[:,8] + f1**3*self.P13l[:,9] # *1
        self.Ploopl[:,1] = f1*self.P22l[:,9] + f1**2*self.P22l[:,14] + f1**2*self.P22l[:,15] + f1**3*self.P22l[:,21] + f1**3*self.P22l[:,22] + f1*self.P13l[:,3] + f1**2*self.P13l[:,5] + f1**2*self.P13l[:,6] # *b1
        self.Ploopl[:,2] = f1*self.P22l[:,10] + f1**2*self.P22l[:,16] + f1**2*self.P22l[:,17] # *b2
        self.Ploopl[:,3] = f1*self.P13l[:,4] # *b3
        self.Ploopl[:,4] = f1*self.P22l[:,11] + f1**2*self.P22l[:,18] + f1**2*self.P22l[:,19] # *b4
        self.Ploopl[:,5] = self.P22l[:,0] + f1*self.P22l[:,6] + f1**2*self.P22l[:,12] + f1**2*self.P22l[:,13] + self.P13l[:,0] + f1*self.P13l[:,2] # *b1*b1
        self.Ploopl[:,6] = self.P22l[:,1] + f1*self.P22l[:,7] # *b1*b2
        self.Ploopl[:,7] = self.P13l[:,1] # *b1*b3
        self.Ploopl[:,8] = self.P22l[:,2] + f1*self.P22l[:,8] # *b1*b4
        self.Ploopl[:,9] = self.P22l[:,3] # *b2*b2
        self.Ploopl[:,10] = self.P22l[:,4] # *b2*b4
        self.Ploopl[:,11] = self.P22l[:,5] # *b4*b4
        
        self.Cloopl[:,0] = f1**2*self.C22[:,20] + f1**3*self.C22[:,23] + f1**3*self.C22[:,24] + f1**4*self.C22[:,25] + f1**4*self.C22[:,26] + f1**4*self.C22[:,27] + f1**2*self.C13[:,7] + f1**3*self.C13[:,8] + f1**3*self.C13[:,9] # *1
        self.Cloopl[:,1] = f1*self.C22[:,9] + f1**2*self.C22[:,14] + f1**2*self.C22[:,15] + f1**3*self.C22[:,21] + f1**3*self.C22[:,22] + f1*self.C13[:,3] + f1**2*self.C13[:,5] + f1**2*self.C13[:,6] # *b1
        self.Cloopl[:,2] = f1*self.C22[:,10] + f1**2*self.C22[:,16] + f1**2*self.C22[:,17] # *b2
        self.Cloopl[:,3] = f1*self.C13[:,4] # *b3
        self.Cloopl[:,4] = f1*self.C22[:,11] + f1**2*self.C22[:,18] + f1**2*self.C22[:,19] # *b4
        self.Cloopl[:,5] = self.C22[:,0] + f1*self.C22[:,6] + f1**2*self.C22[:,12] + f1**2*self.C22[:,13] + self.C13[:,0] + f1*self.C13[:,2] # *b1*b1
        self.Cloopl[:,6] = self.C22[:,1] + f1*self.C22[:,7] # *b1*b2
        self.Cloopl[:,7] = self.C13[:,1] # *b1*b3
        self.Cloopl[:,8] = self.C22[:,2] + f1*self.C22[:,8] # *b1*b4
        self.Cloopl[:,9] = self.C22[:,3] # *b2*b2
        self.Cloopl[:,10] = self.C22[:,4] # *b2*b4
        self.Cloopl[:,11] = self.C22[:,5] # *b4*b4
        
    def setreducePslb(self, bs, co=common):
        b1, b2, b3, b4, b5, b6, b7 = bs
        f = self.f
        
        b11 = np.array([ b1**2, 2.*b1*f, f**2 ])
        bct = np.array([ 2.*b1*b5, 2.*b1*b6, 2.*b1*b7, 2.*f*b5, 2.*f*b6, 2.*f*b7 ])
        bloop = np.array([ 1., b1, b2, b3, b4, b1*b1, b1*b2, b1*b3, b1*b4, b2*b2, b2*b4, b4*b4 ])
        self.Ps[0] = np.einsum('b,lbx->lx', b11, self.P11l)
        self.Ps[1] = np.einsum('b,lbx->lx', bloop, self.Ploopl)
        for l in range(co.Nl): self.Ps[1,l] -= self.Ps[1,l,0]
        self.Ps[1] += np.einsum('b,lbx->lx', bct, self.Pctl)
        self.setfullPs()

    def subtractShotNoise(self, co=common):
        for l in range(co.Nl): 
            for n in range(co.Nloop):
                shotnoise = self.Ploopl[l,n,0]
                self.Ploopl[l,n] -= shotnoise

    def formatTaylor(self, co=common):
        allk = np.concatenate([co.k, co.k]).reshape(-1,1)
        Plin = np.flip(np.einsum('n,lnk->lnk', np.array([1., 2.*self.f, self.f**2]), self.P11l), axis=1) 
        Plin = np.concatenate( np.einsum('lnk->lkn', Plin) , axis=0)
        Plin = np.hstack(( allk, Plin )) 
        Ploop1 = np.concatenate( np.einsum('lnk->lkn', self.Ploopl) , axis=0)
        Ploop2 = np.einsum('n,lnk->lnk', np.array([2., 2., 2., 2.*self.f, 2.*self.f, 2.*self.f]), self.Pctl)
        Ploop2 = np.concatenate( np.einsum('lnk->lkn', Ploop2) , axis=0)
        Ploop = np.hstack((allk, Ploop1, Ploop2))
        return Plin, Ploop

    def setmargPsCfl(self, bs, co=common):

        b1, b2, _, b4, _, _, _ = bs
        f = self.f

        for i in range(co.Nl):
            l = 2*i
            self.b11[i] = b1**2*mu[0][l] + 2.*b1*f*mu[2][l] + f**2*mu[4][l]
            self.b22[i] = np.array([ b1**2*mu[0][l], b1*b2*mu[0][l], b1*b4*mu[0][l], b2**2*mu[0][l], b2*b4*mu[0][l], b4**2*mu[0][l], b1**2*f*mu[2][l], b1*b2*f*mu[2][l], b1*b4*f*mu[2][l], b1*f*mu[2][l], b2*f*mu[2][l], b4*f*mu[2][l], b1**2*f**2*mu[2][l], b1**2*f**2*mu[4][l], b1*f**2*mu[2][l], b1*f**2*mu[4][l], b2*f**2*mu[2][l], b2*f**2*mu[4][l], b4*f**2*mu[2][l], b4*f**2*mu[4][l], f**2*mu[4][l], b1*f**3*mu[4][l], b1*f**3*mu[6][l], f**3*mu[4][l], f**3*mu[6][l], f**4*mu[4][l], f**4*mu[6][l], f**4*mu[8][l] ])
        
        self.P13l = np.einsum('nx,ln->lnx', self.P13, co.l13)
        self.C13 = np.einsum('lnx,ln->lnx', self.C13, co.l13)

        b13nob3 = np.array([1., b1, b1**2])
        P13nob3 = np.array([ f**2*self.P13l[:,7] + f**3*self.P13l[:,8] + f**3*self.P13l[:,9],   # *1
                            + f*self.P13l[:,3] + f**2*self.P13l[:,5] + f**2*self.P13l[:,6],     # *b1
                            + self.P13l[:,0] + f*self.P13l[:,2]                                 # *b1*b1 
                            ])
        C13nob3 = np.array([ f**2*self.C13[:,7] + f**3*self.C13[:,8] + f**3*self.C13[:,9],   # *1
                            + f*self.C13[:,3] + f**2*self.C13[:,5] + f**2*self.C13[:,6],     # *b1
                            + self.C13[:,0] + f*self.C13[:,2]                                # *b1*b1 
                            ])

        self.Ps[0] = np.einsum('l,x->lx', self.b11, self.P11)
        self.Ps[1] = np.einsum('lb,bx->lx', self.b22, self.P22)
        for l in range(co.Nl): self.Ps[1,l] -= self.Ps[1,l,0]
        self.Ps[1] += np.einsum('b,blx->lx', b13nob3, P13nob3)

        self.Cf[0] = np.einsum('l,lx->lx', self.b11, self.C11)
        self.Cf[1] = np.einsum('lb,lbx->lx', self.b22, self.C22) + np.einsum('b,blx->lx', b13nob3, C13nob3)

        self.Pb3 = f*self.P13l[:,4] + b1*self.P13l[:,1]     # *b3 + *b1*b3
        self.Cb3 = f*self.C13[:,4] + b1*self.C13[:,1]     # *b3 + *b1*b3

        self.Pctl = np.einsum('x,x,ln->lnx', co.k**2, self.P11, co.lct)
        self.Pctl = np.einsum('x,x,ln->lnx', co.k**2, self.P11, co.lct)

    def setmargPslb(self, bs, co=common):
        b1, _, b3, _, b5, b6, b7 = bs
        f = self.f
        bct = np.array([ 2.*b1*b5, 2.*b1*b6, 2.*b1*b7, 2.*f*b5, 2.*f*b6, 2.*f*b7 ])
        self.Ps[1] += b3*self.Pb3 + np.einsum('b,lbx->lx', bct, self.Pctl)
        self.setfullPs()


def CoefWindow(N, window=1):
    n = np.arange(-N//2,N//2+1)
    if window is 1: n_cut = N//2
    else: n_cut = int(window*N//2.)
    
    n_right = n[-1] - n_cut
    n_left = n[0]+ n_cut 

    n_r=n[ n[:]  > n_right ] 
    n_l=n[ n[:]  <  n_left ]

    theta_right=(n[-1]-n_r)/float(n[-1]-n_right-1) 
    theta_left=(n_l - n[0])/float(n_left-n[0]-1)
    
    W=np.ones(n.size)
    W[n[:] > n_right]= theta_right - 1/(2*pi)*sin(2*pi*theta_right)
    W[n[:] < n_left]= theta_left - 1/(2*pi)*sin(2*pi*theta_left)
    
    return W

class FFTLog(object):
    def __init__(self, **kwargs):
        self.Nmax = kwargs['Nmax']
        self.xmin = kwargs['xmin']
        self.xmax = kwargs['xmax']
        self.bias = kwargs['bias']
        self.dx = np.log(self.xmax/self.xmin) / (self.Nmax-1.)
        self.setx()
        self.setPow()
    
    def setx(self):
        self.x = np.empty(self.Nmax)
        for i in range(self.Nmax): 
            self.x[i] = self.xmin * np.exp(i*self.dx)
    
    def setPow(self):
        self.Pow = np.empty(self.Nmax+1, dtype = complex)
        for i in range(self.Nmax+1): 
            self.Pow[i] = self.bias + 1j * 2.*np.pi / (self.Nmax*self.dx) * (i - self.Nmax/2.)
    
    def Coef(self, xin, f, extrap='extrap', window=1, co=common):
        
        interpfunc = interp1d(xin, f, kind='cubic')
        
        fx = np.empty(self.Nmax)
        tmp = np.empty(int(self.Nmax/2+1), dtype = complex)
        Coef = np.empty(self.Nmax+1, dtype = complex)
        
        if extrap is 'extrap':
            if xin[0] > self.x[0]:
                #print ('low extrapolation')
                nslow = (log(f[1])-log(f[0])) / (log(xin[1])-log(xin[0]))
                Aslow = f[0] / xin[0]**nslow
            if xin[-1] < self.x[-1]:
                #print ('high extrapolation')
                nshigh = (log(f[-1])-log(f[-2])) / (log(xin[-1])-log(xin[-2]))
                Ashigh = f[-1] / xin[-1]**nshigh
                
            for i in range(self.Nmax): 
                if xin[0] > self.x[i]: fx[i] = Aslow * self.x[i]**nslow * np.exp(-self.bias*i*self.dx)
                elif xin[-1] < self.x[i]: fx[i] = Ashigh * self.x[i]**nshigh * np.exp(-self.bias*i*self.dx)
                else: fx[i] = interpfunc(self.x[i]) * np.exp(-self.bias*i*self.dx)
        
        elif extrap is'padding':
            for i in range(self.Nmax): 
                if xin[0] > self.x[i]: fx[i] = 0.
                elif xin[-1] < self.x[i]: fx[i] = 0.
                else: fx[i] = interpfunc(self.x[i]) * np.exp(-self.bias*i*self.dx)
                
        #tmp = rfft(fx) ### numpy
        tmp = rfft(fx, planner_effort='FFTW_ESTIMATE')() ### pyfftw
        
        for i in range(self.Nmax+1):
            if (i < self.Nmax/2): Coef[i] = np.conj(tmp[int(self.Nmax/2-i)]) * self.xmin**(-self.Pow[i]) / float(self.Nmax)
            else: Coef[i] = tmp[int(i-self.Nmax/2)] * self.xmin**(-self.Pow[i]) / float(self.Nmax)
        
        if window is not None: Coef = Coef*CoefWindow(self.Nmax, window=window)
        else:
            Coef[0] /= 2.
            Coef[self.Nmax] /= 2.
        
        return Coef
        #return self.x, 
    
    def sumCoefxPow(self, xin, f, x, window=1):    
        Coef = self.Coef(xin, f, window=window)
        fFFT = np.empty_like(x)
        for i, xi in enumerate(x):
            fFFT[i] = np.real( np.sum(Coef * xi**self.Pow) )
        return fFFT

class NonLinear(object):
    def __init__(self, co=common, load=True, save=True, path='./', NFFT=256):
        
        self.fftsettings = dict(Nmax=NFFT, xmin=1.5e-5, xmax=1000., bias=-1.6)
        
        self.fft = FFTLog(**self.fftsettings)
        
        if load is True:
            try:
                L = np.load(os.path.join(path, 'pyegg%s.npz')%NFFT)
                if (self.fft.Pow-L['Pow']).any():
                    print ('Loaded loop matrices do not correspond to asked FFTLog configuration. \n Computing new matrices.')
                    load = False
                else:
                    self.M22, self.M13, self.Mcf11, self.Mcf22, self.Mcf13, self.Mcfct = L['M22'], L['M13'], L['Mcf11'], L['Mcf22'], L['Mcf13'], L['Mcfct']
            except:
                print ('Can\'t load loop matrices at %s. \n Computing new matrices.'%path)
                load = False
        
        if load is False:
            self.setM22()
            self.setM13()
            self.setMl()
            self.setMcf11()
            self.setMcf22()
            self.setMcf13()
            self.setMcfct()
        
        if save is True:
            try:
                np.savez( os.path.join(path, 'pyegg%s.npz')%NFFT, Pow=self.fft.Pow,
                     M22=self.M22, M13=self.M13, Mcf11=self.Mcf11, Mcf22=self.Mcf22, Mcf13=self.Mcf13, Mcfct=self.Mcfct )
            except:
                print ('Can\'t save loop matrices at %s.'%path)
        
        self.setkPow(co=co)
        self.setsPow(co=co)
        
        # To speed-up matrix multiplication:
        self.optipathP22 = np.einsum_path('nk,mk,bnm->bk', self.kPow, self.kPow, self.M22, optimize='optimal')[0]
        self.optipathC13 = np.einsum_path('ns,ms,blnm->bls', self.sPow, self.sPow, self.Mcf22, optimize='optimal')[0]
        self.optipathC22 = np.einsum_path('ns,ms,blnm->bls', self.sPow, self.sPow, self.Mcf13, optimize='optimal')[0]
        
    def setM22(self, co=common):
        self.M22 = np.empty(shape=(co.N22, self.fft.Pow.shape[0], self.fft.Pow.shape[0]), dtype='complex')
        # common piece of M22
        Ma = np.empty(shape=(self.fft.Pow.shape[0], self.fft.Pow.shape[0]), dtype='complex')
        for u, n1 in enumerate(-0.5*self.fft.Pow):
            for v, n2 in enumerate(-0.5*self.fft.Pow):
                Ma[u,v] = M22a(n1, n2)
        for i in range(co.N22): 
            # singular piece of M22
            Mb = np.empty(shape=(self.fft.Pow.shape[0], self.fft.Pow.shape[0]), dtype='complex')
            for u, n1 in enumerate(-0.5*self.fft.Pow):
                for v, n2 in enumerate(-0.5*self.fft.Pow):
                    Mb[u,v] = M22b[i](n1, n2)
            self.M22[i] = Ma*Mb
    
    def setM13(self, co=common):
        self.M13 = np.empty(shape=(co.N13, self.fft.Pow.shape[0]), dtype='complex')
        Ma = M13a(-0.5*self.fft.Pow)
        for i in range(co.N13): self.M13[i] = Ma*M13b[i](-0.5*self.fft.Pow)
    
    def setMcf11(self, co=common):
        self.Mcf11 = np.empty(shape=(co.Nl, self.fft.Pow.shape[0]), dtype='complex')
        for l in range(co.Nl):
            for u, n1 in enumerate(-0.5*self.fft.Pow):
                self.Mcf11[l,u] = MPC(2*l, n1)
        
    def setMl(self, co=common):
        self.Ml = np.empty(shape=(co.Nl, self.fft.Pow.shape[0], self.fft.Pow.shape[0]), dtype='complex')
        for l in range(co.Nl):
            for u, n1 in enumerate(-0.5*self.fft.Pow):
                for v, n2 in enumerate(-0.5*self.fft.Pow):
                    self.Ml[l,u,v] = MPC(2*l, n1+n2-1.5)
    
    def setMcf22(self):
        self.Mcf22 = np.einsum('lnm,bnm->blnm', self.Ml, self.M22)
    
    def setMcf13(self):
        self.Mcf13 = np.einsum('lnm,bn->blnm', self.Ml, self.M13)
    
    def setMcfct(self, co=common):
        self.Mcfct = np.empty(shape=(co.Nl, self.fft.Pow.shape[0]), dtype='complex')
        for l in range(co.Nl):
            for u, n1 in enumerate(-0.5*self.fft.Pow-1.):
                self.Mcfct[l,u] = MPC(2*l, n1)
    
    def setkPow(self, co=common):
        self.kPow = np.exp(np.einsum('n,k->nk', self.fft.Pow, np.log(co.k)))
    
    def setsPow(self, co=common):
        self.sPow = np.exp(np.einsum('n,s->ns', -self.fft.Pow-3., np.log(co.s)))
    
    def CoefkPow(self, Coef):
        return np.einsum('n,nk->nk', Coef, self.kPow )
    
    def CoefsPow(self, Coef):
        return np.einsum('n,ns->ns', Coef, self.sPow )
    
    def makeP22(self, CoefkPow, bird, co=common):
        bird.P22 = co.k**3 * np.real( np.einsum('nk,mk,bnm->bk', CoefkPow, CoefkPow, self.M22, optimize=self.optipathP22 ) )
    
    def makeP13(self, CoefkPow, bird, co=common):
        bird.P13 = co.k**3 * bird.P11 * np.real( np.einsum('nk,bn->bk', CoefkPow, self.M13) )
        
    def makeC11(self, CoefsPow, bird):
        bird.C11 = np.real( np.einsum('ns,ln->ls', CoefsPow, self.Mcf11) )
    
    def makeCct(self, CoefsPow, bird, co=common):
        bird.Cct = co.s**-2 * np.real( np.einsum('ns,ln->ls', CoefsPow, self.Mcfct) )
        
    def makeC22(self, CoefsPow, bird):
        bird.C22 = np.real( np.einsum('ns,ms,blnm->lbs', CoefsPow, CoefsPow, self.Mcf22, optimize=self.optipathC22 ) )
    
    def makeC13(self, CoefsPow, bird):
        bird.C13 = np.real( np.einsum('ns,ms,blnm->lbs', CoefsPow, CoefsPow, self.Mcf13, optimize=self.optipathC13 ) )
        
    def Coef(self, bird, window=None, co=common):
#         if bird.kin[0] > self.fftsettings['xmin']: print ('Please provide a linear power spectrum with kmin < %s'%self.fftsettings['xmin'])
#         if bird.kin[-1] < self.fftsettings['xmax']: print ('Please provide a linear power spectrum with kmax > %s'%self.fftsettings['xmax'])
        return self.fft.Coef(bird.kin, bird.Pin, window=window)
    
    def Ps(self, bird, window=None, co=common):
        coef = self.Coef(bird, window=window, co=co)
        coefkPow = self.CoefkPow(coef)
        self.makeP22(coefkPow, bird, co=co)
        self.makeP13(coefkPow, bird, co=co)
        
    def Cf(self, bird, window=.6, co=common):
        coef = self.Coef(bird, window=window, co=co)
        coefsPow = self.CoefsPow(coef)
        self.makeC11(coefsPow, bird)
        self.makeCct(coefsPow, bird, co=co)
        self.makeC22(coefsPow, bird)
        self.makeC13(coefsPow, bird)
    
    def PsCf(self, bird, window=.6, co=common):
        coef = self.Coef(bird, window=window, co=co)
        coefkPow = self.CoefkPow(coef)
        coefsPow = self.CoefsPow(coef)
        self.makeP22(coefkPow, bird, co=co)
        self.makeP13(coefkPow, bird, co=co)
        self.makeC11(coefsPow, bird)
        self.makeCct(coefsPow, bird, co=co)
        self.makeC22(coefsPow, bird)
        self.makeC13(coefsPow, bird)

class Resum(object):
    def __init__(self, co=common, LambdaIR=.2, NFFT=192):
        
        self.LambdaIR = LambdaIR
        
        self.NIR = 32-4
        
        # can put those to empty
        self.Q = np.zeros(shape=(2, co.Nl, co.Nl, self.NIR))
        self.IRcorr = np.zeros(shape=(2, co.Nl, self.NIR, co.Nkr))
        self.IR11 = np.zeros(shape=(co.Nl, self.NIR, co.Nkr))
        self.IRct = np.zeros(shape=(co.Nl, self.NIR, co.Nkr))
        self.IRloop = np.zeros(shape=(co.Nl, co.Nloop, self.NIR, co.Nkr))
        
        # keep these to zeros for padding zeros at low k
        self.IRresum = np.zeros(shape=(2, co.Nl, co.Nk))
        self.IR11resum = np.zeros(shape=(co.Nl, co.N11, co.Nk))
        self.IRctresum = np.zeros(shape=(co.Nl, co.Nct, co.Nk))
        self.IRloopresum = np.zeros(shape=(co.Nl, co.Nloop, co.Nk))

        # for marg
        self.IRb3 = np.zeros(shape=(co.Nl, self.NIR, co.Nkr))
        self.IRb3resum = np.zeros(shape=(co.Nl, co.Nk))
        
        self.fftsettings = dict(Nmax=NFFT, xmin=.1, xmax=10000., bias=-0.6)
        
        self.fft = FFTLog(**self.fftsettings)
        self.setM(co=co)
        self.setkPow()
        
        self.Xfftsettings = dict(Nmax=32, xmin=1.5e-5, xmax=10., bias=-2.6)
        self.Xfft = FFTLog(**self.Xfftsettings)
        self.setXM()
        self.setXsPow()
        
        k2pi = np.array([co.kr**2, co.kr**4, co.kr**6, co.kr**8, co.kr**10, co.kr**12, co.kr**14, co.kr**16])
        self.k2p = np.concatenate((k2pi, k2pi))
        
        self.alllpr = [
            [0,1], [0,1], [0,1], [0,1], [0,1], [0,1], [0,1], [0,1], 
            [0,1], [0,1], [0,1], [0,1], [0,1], [0,1], #[0,1], [0,1], 
        ]

        
    
    def setXsPow(self, co=common):
        self.XsPow = np.exp(np.einsum('n,s->ns', -self.Xfft.Pow-3., np.log(co.sr)))
    
    def setkPow(self, co=common):
        self.kPow = np.exp(np.einsum('n,s->ns', -self.fft.Pow-3., np.log(co.kr)))
    
    def setXM(self):
        self.XM = np.empty(shape=(2, self.Xfft.Pow.shape[0]), dtype='complex')
        for l in range(2):
            self.XM[l] = MPC(2*l, -0.5*self.Xfft.Pow)
        
    def IRFilters(self, bird, soffset=1., LambdaIR=None, RescaleIR=1., window=None, co=common):
        if LambdaIR is None: LambdaIR = self.LambdaIR
        Coef = self.Xfft.Coef(bird.kin, bird.Pin * np.exp(-bird.kin**2/LambdaIR**2)/bird.kin**2, window=window)
        CoefsPow = np.einsum('n,ns->ns', Coef, self.XsPow )
        X02 = np.real( np.einsum('ns,ln->ls', CoefsPow, self.XM) )
        X0offset = np.real( np.einsum('n,n->', np.einsum('n,n->n', Coef, soffset**(-self.Xfft.Pow-3.)), self.XM[0]) )
        X02[0] = X0offset-X02[0]
        X = RescaleIR * 2./3. * (X02[0] - X02[1])
        Y = 2. * X02[1]
        return X, Y
        
    def setM(self, co=common):
        self.M = np.empty(shape=(co.Nl, self.fft.Pow.shape[0]), dtype='complex')
        for l in range(co.Nl):
            self.M[l] = 8.*pi**3*MPC(2*l, -0.5*self.fft.Pow)
        
    def IRCorrection(self, XpYpC, k2p, lpr=None, window=None, co=common):
        Coef = self.fft.Coef(co.sr, XpYpC, extrap='padding', window=window)
        CoefkPow = np.einsum('n,nk->nk', Coef, self.kPow)
        return k2p * np.real( np.einsum('nk,ln->lk', CoefkPow, self.M) )
    
    def makeQ(self, f, co=common):
        for a in range(2):
            for l in range(co.Nl):
                for lpr in range(co.Nl):
                    for u in range(self.NIR):
                        self.Q[a][l][lpr][u] = Qa[1-a][2*l][2*lpr][u](f)
    
    def extractBAO(self, cf, co=common):
        # cfnobao = np.concatenate([cf[...,:co.idlow], cf[...,co.idhigh:]], axis = -1)
        # nobao = interp1d(co.snobao, co.snobao**2 * cfnobao, kind='linear', axis=-1)(co.sbao) * co.sbao**-2
        # bao = cf[...,co.idlow:co.idhigh]-nobao
        # return bao
        return cf
    
    def Ps(self, bird, full=True, marg=False, window=None, co=common):
        self.makeQ(bird.f, co=co)

        X, Y = self.IRFilters(bird)
        Xp = np.array([X, X**2, X**3, X**4, X**5, X**6, X**7, X**8])
        XpY = np.array([Y, X*Y, X**2*Y, X**3*Y, X**4*Y, X**5*Y, X**6*Y, X**7*Y])
        
        XpYp = np.concatenate((Xp, XpY))

        if marg is True:
            full = False

            for a, cf in enumerate(bird.Cf):
                cbao = 1.*self.extractBAO(cf, co=co)
                for l, cl in enumerate(cbao):
                    u = 0
                    for j, (xy, k2pj, lpr) in enumerate(zip(XpYp, self.k2p, self.alllpr)):
                        IRcorrUnsorted = self.IRCorrection(xy*cl, k2pj, lpr=lpr, window=window, co=co)
                        for v in range(len(lpr)):
                            self.IRcorr[a,l,u+v] = IRcorrUnsorted[v]
                        u += len(lpr)
            self.IRresum[...,co.Nklow:] = np.einsum('alpn,apnk->alk', self.Q, self.IRcorr)
            bird.Ps += self.IRresum
            
            cbao = self.extractBAO(bird.Cct, co=co)
            for l, cl in enumerate(cbao):
                u = 0
                for j, (xy, k2pj, lpr) in enumerate(zip(XpYp, self.k2p, self.alllpr)):
                    IRcorrUnsorted = self.IRCorrection(xy*cl, k2pj, lpr=lpr, window=window, co=co)
                    for v in range(len(lpr)): self.IRct[l,u+v] = IRcorrUnsorted[v]
                    u += len(lpr)
            self.IRctresum[..., co.Nklow:] = np.einsum('lpn,pnk,pi->lik', self.Q[1], self.IRct, co.lct)
            bird.Pctl += self.IRctresum

            cbao = self.extractBAO(bird.Cb3, co=co)
            for l, cl in enumerate(cbao):
                u = 0
                for j, (xy, k2pj, lpr) in enumerate(zip(XpYp, self.k2p, self.alllpr)):
                    IRcorrUnsorted = self.IRCorrection(xy*cl, k2pj, lpr=lpr, window=window, co=co)
                    for v in range(len(lpr)): self.IRb3[l,u+v] = IRcorrUnsorted[v]
                    u += len(lpr)
            self.IRb3resum[..., co.Nklow:] = np.einsum('lpn,pnk->lk', self.Q[1], self.IRb3)
            bird.Pb3 += self.IRb3resum
        
        elif full is True:
            for a, cf in enumerate(bird.Cf):
                cbao = 1.*self.extractBAO(cf, co=co)
                for l, cl in enumerate(cbao):
                    u = 0
                    for j, (xy, k2pj, lpr) in enumerate(zip(XpYp, self.k2p, self.alllpr)):
                        IRcorrUnsorted = self.IRCorrection(xy*cl, k2pj, lpr=lpr, window=window, co=co)
                        for v in range(len(lpr)):
                            self.IRcorr[a,l,u+v] = IRcorrUnsorted[v]
                        u += len(lpr)
            self.IRresum[...,co.Nklow:] = np.einsum('alpn,apnk->alk', self.Q, self.IRcorr)
            bird.Ps += self.IRresum
            bird.setfullPs()

        else:
            cbao = self.extractBAO(bird.C11, co=co)
            for l, cl in enumerate(cbao):
                u = 0
                for j, (xy, k2pj, lpr) in enumerate(zip(XpYp, self.k2p, self.alllpr)):
                    IRcorrUnsorted = self.IRCorrection(xy*cl, k2pj, lpr=lpr, window=window, co=co)
                    for v in range(len(lpr)): self.IR11[l,u+v] = IRcorrUnsorted[v]
                    u += len(lpr)
            cbao = self.extractBAO(bird.Cct, co=co)
            for l, cl in enumerate(cbao):
                u = 0
                for j, (xy, k2pj, lpr) in enumerate(zip(XpYp, self.k2p, self.alllpr)):
                    IRcorrUnsorted = self.IRCorrection(xy*cl, k2pj, lpr=lpr, window=window, co=co)
                    for v in range(len(lpr)): self.IRct[l,u+v] = IRcorrUnsorted[v]
                    u += len(lpr)
            cbao = self.extractBAO(bird.Cloopl, co=co)
            for l, cl in enumerate(cbao):
                for i, cli in enumerate(cl):
                    u = 0
                    for j, (xy, k2pj, lpr) in enumerate(zip(XpYp, self.k2p, self.alllpr)):
                        IRcorrUnsorted = self.IRCorrection(xy*cli, k2pj, lpr=lpr, window=window, co=co)
                        for v in range(len(lpr)): self.IRloop[l,i,u+v] = IRcorrUnsorted[v]
                        u += len(lpr)
            self.IR11resum[..., co.Nklow:] = np.einsum('lpn,pnk,pi->lik', self.Q[0], self.IR11, co.l11)
            self.IRctresum[..., co.Nklow:] = np.einsum('lpn,pnk,pi->lik', self.Q[1], self.IRct, co.lct)
            self.IRloopresum[..., co.Nklow:] = np.einsum('lpn,pink->lik', self.Q[1], self.IRloop)
            bird.P11l += self.IR11resum
            bird.Pctl += self.IRctresum
            bird.Ploopl += self.IRloopresum
